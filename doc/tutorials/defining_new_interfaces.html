<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Defining new interfaces &mdash; pyqi: expose your interface</title>
    
    <link rel="stylesheet" href="../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.3.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/theme_extras.js"></script>
    <link rel="top" title="pyqi: expose your interface" href="../index.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="../index.html">
          <span>pyqi: expose your interface</span></a></h1>
        <h2 class="heading"><span>Defining new interfaces</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        <a class="uplink" href="../index.html">Contents</a>
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="defining-new-interfaces">
<span id="id1"></span><h1>Defining new interfaces<a class="headerlink" href="#defining-new-interfaces" title="Permalink to this headline">¶</a></h1>
<p>After defining a new <tt class="docutils literal"><span class="pre">Command</span></tt> and its API, as covered in <a class="reference internal" href="defining_new_commands.html#defining-new-commands"><em>Defining new commands</em></a>, you&#8217;re ready to create a first user interface for that command. In this tutorial we&#8217;ll define a command line interface for the <tt class="docutils literal"><span class="pre">SequenceCollectionSummarizer</span></tt> command.</p>
<p>The main differences that need to be handled when defining a command line interface are that we&#8217;ll want the user to provide their sequence collection on the command line, and we&#8217;ll want to write the output to a filepath that the user specifies on the command line. This is different than what happens in <tt class="docutils literal"><span class="pre">SequenceCollectionSummarizer</span></tt>, where the input and output are python objects. This is a very important distinction - since our derived <tt class="docutils literal"><span class="pre">Commands</span></tt> are meant to be interface-independent, they should not do things like require files as input. In some rare circumstances, it may be required for a <tt class="docutils literal"><span class="pre">Command</span></tt> to write files as its output (for example, if storing the output in memory is intractable).</p>
<p>pyqi currently provides support for building command line interfaces based on python&#8217;s <a class="reference external" href="http://docs.python.org/2/library/optparse.html">optparse</a> module. Your interface will ultimately be an instance of <tt class="docutils literal"><span class="pre">pyqi.interfaces.optparse.OptparseInterface</span></tt>, but the interface class itself is generated dynamically. As a developer, you only define the configuration for the interface via an <em>interface configuration file</em> (which is a valid python file) - you won&#8217;t actually define the interface class itself. If this sounds confusing, just get started - it&#8217;s easier than it sounds.</p>
<div class="section" id="stubbing-a-new-command-line-interface">
<h2>Stubbing a new command line interface<a class="headerlink" href="#stubbing-a-new-command-line-interface" title="Permalink to this headline">¶</a></h2>
<p>pyqi provides a command, <tt class="docutils literal"><span class="pre">make-optparse</span></tt>, that allows developers to easily stub (i.e., create templates for) their optparse interface configuration files. After installing pyqi, you can get usage information by calling:</p>
<div class="highlight-python"><pre>pyqi make-optparse -h</pre>
</div>
<p>To create your interface, you&#8217;ll need to pass the <tt class="docutils literal"><span class="pre">Command</span></tt> as a fully specified python module name, the name of the module where that <tt class="docutils literal"><span class="pre">Command</span></tt> is defined, and the path where the new configuration file should be written. For example, to create a stub for an <tt class="docutils literal"><span class="pre">OptparseInterface</span></tt> for our <tt class="docutils literal"><span class="pre">SequenceCollectionSummarizer</span></tt> command, you could run the following:</p>
<div class="highlight-python"><pre>pyqi make-optparse -c sequence_collection_summarizer.SequenceCollectionSummarizer -m sequence_collection_summarizer --credits "Greg Caporaso" -o summarize_sequence_collection.py</pre>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">For the above command to work, the directory containing <tt class="docutils literal"><span class="pre">sequence_collection_summarizer.py</span></tt> will need to be in your <tt class="docutils literal"><span class="pre">$PYTHONPATH</span></tt>.</p>
</div>
<p>The resulting file will look something like this:</p>
<div class="highlight-python"><pre>#!/usr/bin/env python
from __future__ import division

__credits__ = ["Greg Caporaso"]

from pyqi.core.interfaces.optparse import (OptparseUsageExample,
                                           OptparseOption, OptparseResult)
from pyqi.core.command import (make_command_in_collection_lookup_f,
                               make_command_out_collection_lookup_f)
from sequence_collection_summarizer import CommandConstructor

# If you need access to input or output handlers provided by pyqi, consider
# importing from the following modules:
# pyqi.core.interfaces.optparse.input_handler
# pyqi.core.interfaces.optparse.output_handler
# pyqi.interfaces.optparse.input_handler
# pyqi.interfaces.optparse.output_handler

# Convenience function for looking up parameters by name.
cmd_in_lookup = make_command_in_collection_lookup_f(CommandConstructor)
cmd_out_lookup = make_command_out_collection_lookup_f(CommandConstructor)

# Examples of how the command can be used from the command line using an
# optparse interface.
usage_examples = [
    OptparseUsageExample(ShortDesc="A short single sentence description of the example",
                         LongDesc="A longer, more detailed description",
                         Ex="%prog --foo --bar some_file")
]

# inputs map command line arguments and values onto Parameters. It is possible
# to define options here that do not exist as parameters, e.g., an output file.
inputs = [
    # An example option that has a direct relationship with a Parameter.
    # OptparseOption(Parameter=cmd_in_lookup('name_of_a_command_in'),
    #                Type='existing_filepath', # the optparse type of input
    #                Action='store', # the optparse action
    #                Handler=None, # Apply a function to the input value to convert it into the type expected by Parameter.DataType
    #                ShortName='n', # a parameter short name, can be None
    #                # Name='foo', # implied by Parameter.Name. Can be overwritten here if desired
    #                # Required=False, # implied by Parameter.Required. Can be promoted by setting True
    #                # Help='help', # implied by Parameter.Description. Can be overwritten here if desired
    #                # Default=None, # implied by Parameter.Default. Can be overwritten here if desired
    #                # DefaultDescription=None, # implied by Parameter.DefaultDescription. Can be overwritten here if desired
    #                convert_to_dashed_name=True), # whether the Name (either implied by Parameter or defined above) should have underscores converted to dashes when displayed to the user
    #
    # An example option that does not have an associated Parameter.
    # OptparseOption(Parameter=None,
    #                Type='new_filepath',
    #                Action='store',
    #                Handler=None, # we don't need a Handler because this option isn't being converted into a format that a Parameter expects
    #                ShortName='o',
    #                Name='output-fp',
    #                Required=True,
    #                Help='output filepath')

    OptparseOption(Parameter=cmd_in_lookup('seqs'),
                   Type=&lt;type 'list'&gt;,
                   Action='store', # default is 'store', change if desired
                   Handler=None, # must be defined if desired
                   ShortName=None, # must be defined if desired
                   # Name='seqs', # implied by Parameter
                   # Required=True, # implied by Parameter
                   # Help='sequences to be summarized', # implied by Parameter
                   ),
    OptparseOption(Parameter=cmd_in_lookup('suppress_length_summary'),
                   Type=None,
                   Action='store_true', # default is 'store', change if desired
                   Handler=None, # must be defined if desired
                   ShortName=None, # must be defined if desired
                   # Name='suppress_length_summary', # implied by Parameter
                   # Required=False, # implied by Parameter
                   # Help='do not generate summary information on the sequence lengths', # implied by Parameter
                   # Default=False, # implied by Parameter
                   # DefaultDescription=None, # implied by Parameter),
]

# outputs map result keys to output options and handlers. It is not necessary
# to supply an associated option, but if you do, it must be an option from the
# inputs list (above).
outputs = [
    # An example option that maps to a CommandIn.
    # OptparseResult(Parameter=cmd_out_lookup('name_of_a_command_out'),
    #                Handler=write_string, # a function applied to the output of the Command
    #                # the name of the option (defined in inputs, above), whose
    #                # value will be made available to Handler. This name
    #                # can be either an underscored or dashed version of the
    #                # option name (e.g., 'output_fp' or 'output-fp')
    #                InputName='output-fp'),
    #
    # An example option that does not map to a CommandIn.
    # OptparseResult(Parameter=cmd_out_lookup('some_other_result'),
    #                Handler=print_string)

    OptparseResult(Parameter=cmd_out_lookup('max_length'),
                    Handler=None, # must be defined
                    InputName=None), # define if tying to an OptparseOption
    OptparseResult(Parameter=cmd_out_lookup('min_length'),
                    Handler=None, # must be defined
                    InputName=None), # define if tying to an OptparseOption
    OptparseResult(Parameter=cmd_out_lookup('num_seqs'),
                    Handler=None, # must be defined
                    InputName=None), # define if tying to an OptparseOption
]</pre>
</div>
<p>There are three lists of values that we&#8217;ll need to populate here to define the optparse interface for our <tt class="docutils literal"><span class="pre">SequenceCollectionSummarizer</span></tt> command. These are the <tt class="docutils literal"><span class="pre">inputs</span></tt>, the <tt class="docutils literal"><span class="pre">outputs</span></tt>, and the <tt class="docutils literal"><span class="pre">usage_examples</span></tt>. We&#8217;ll also need to define an input handler and an output handler to tell the <tt class="docutils literal"><span class="pre">OptparseInterface</span></tt> how to take input from the command line and turn it into something that <tt class="docutils literal"><span class="pre">SequenceCollectionSummarizer</span></tt> can use, and to take output from <tt class="docutils literal"><span class="pre">SequenceCollectionSummarizer</span></tt> and turn it into something a command line user will want. <tt class="docutils literal"><span class="pre">make-optparse</span></tt> will auto-populate the <tt class="docutils literal"><span class="pre">inputs</span></tt>  and <tt class="docutils literal"><span class="pre">outputs</span></tt> based on the <tt class="docutils literal"><span class="pre">CommandIns</span></tt> and <tt class="docutils literal"><span class="pre">CommandOuts</span></tt>, but some changes will usually be required (detailed below). The following sections describe each of these steps.</p>
</div>
<div class="section" id="defining-usage-examples">
<h2>Defining usage examples<a class="headerlink" href="#defining-usage-examples" title="Permalink to this headline">¶</a></h2>
<p>The first thing to do when defining the <tt class="docutils literal"><span class="pre">OptparseInterface</span></tt> for our <tt class="docutils literal"><span class="pre">SequenceCollectionSummarizer</span></tt> command is define a set of usage examples. While in practice this documentation step may seem like something you&#8217;d want to do last, it&#8217;s really helpful to do first to get you thinking about how you&#8217;d like to interact with your command from the command line.</p>
<p>Usage examples are defined as instances of the <tt class="docutils literal"><span class="pre">pyqi.core.interfaces.optparse.OptparseUsageExample</span></tt> class, and are instantiated with three parameters: <tt class="docutils literal"><span class="pre">ShortDescription</span></tt>, <tt class="docutils literal"><span class="pre">LongDescription</span></tt>, and <tt class="docutils literal"><span class="pre">Ex</span></tt>. <tt class="docutils literal"><span class="pre">Ex</span></tt> is the usage example itself, <tt class="docutils literal"><span class="pre">ShortDescription</span></tt> is a one sentence description of what <tt class="docutils literal"><span class="pre">Ex</span></tt> will do, and <tt class="docutils literal"><span class="pre">LongDescription</span></tt> elaborates on what <tt class="docutils literal"><span class="pre">Ex</span></tt> does. Find the <tt class="docutils literal"><span class="pre">usage_examples</span></tt> list in your new <tt class="docutils literal"><span class="pre">summarize_sequence_collection.py</span></tt> file, and replace its definition with:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">usage_examples</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">OptparseUsageExample</span><span class="p">(</span><span class="n">ShortDesc</span><span class="o">=</span><span class="s">&quot;Summarize the input sequence collection and write the result to file.&quot;</span><span class="p">,</span>
                         <span class="n">LongDesc</span><span class="o">=</span><span class="s">&quot;Read the file specified by -i, and compute the number of sequences in the file, and the minimum and maximum sequence lengths. Write all of that information to path specified by -o.&quot;</span><span class="p">,</span>
                         <span class="n">Ex</span><span class="o">=</span><span class="s">&quot;%prog -i seqs.fna -o seqs.summary.txt&quot;</span><span class="p">),</span>
    <span class="n">OptparseUsageExample</span><span class="p">(</span><span class="n">ShortDesc</span><span class="o">=</span><span class="s">&quot;Summarize the input sequence collection and write the result to file, excluding information on sequence lengths.&quot;</span><span class="p">,</span>
                         <span class="n">LongDesc</span><span class="o">=</span><span class="s">&quot;Read the file specified by -i, compute the number of sequences in the file, and write that information to path specified by -o.&quot;</span><span class="p">,</span>
                         <span class="n">Ex</span><span class="o">=</span><span class="s">&quot;%prog -i seqs.fna -o seqs.summary.txt --suppress-length-summary&quot;</span><span class="p">)</span>
<span class="p">]</span>
</pre></div>
</div>
<p>Here we define two usage examples, each of which gives us an idea about how we want our script to behave: we want it to take an <tt class="docutils literal"><span class="pre">i</span></tt> parameter (where the user passes their input file name), an <tt class="docutils literal"><span class="pre">o</span></tt> parameter (where the user passes their output file name), and an optional parameter called <tt class="docutils literal"><span class="pre">suppress-length-summary</span></tt> which controls some of the script behavior.</p>
<blockquote>
<div><div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">You shouldn&#8217;t ever include the name of the script when defining <tt class="docutils literal"><span class="pre">OptparseUsageExample.Ex</span></tt>, but instead include the text <tt class="docutils literal"><span class="pre">%prog</span></tt>. This will be automatically replaced with the script name, so if you ever change the name of the script in the future, the change will take effect in all of your usage examples without you having to remember to update them.</p>
</div>
</div></blockquote>
</div>
<div class="section" id="defining-inputs">
<h2>Defining inputs<a class="headerlink" href="#defining-inputs" title="Permalink to this headline">¶</a></h2>
<p>Next we&#8217;ll define the list of <tt class="docutils literal"><span class="pre">inputs</span></tt> that should be associated with our <tt class="docutils literal"><span class="pre">OptparseInterface</span></tt>. Each of these inputs will be an instance of a <tt class="docutils literal"><span class="pre">pyqi.core.interface.optparse.OptparseOption</span></tt> object. These will roughly map on to the <tt class="docutils literal"><span class="pre">CommandIns</span></tt> that we defined for <tt class="docutils literal"><span class="pre">SequenceCollectionSummarizer</span></tt>, but there are usually additional interface options relative to command parameters, as we&#8217;ll see here.</p>
<p>For the <tt class="docutils literal"><span class="pre">OptparseOptions</span></tt> that map onto <tt class="docutils literal"><span class="pre">CommandIns</span></tt> directly, you can look up the corresponding <tt class="docutils literal"><span class="pre">CommandIn</span></tt> in the <tt class="docutils literal"><span class="pre">cmd_in_lookup</span></tt> dictionary (which is created for you by <tt class="docutils literal"><span class="pre">make-optparse</span></tt>), and most of the information in the <tt class="docutils literal"><span class="pre">OptparseOption</span></tt> will be auto-populated for you. <tt class="docutils literal"><span class="pre">make-optparse</span></tt> will actually fill in as much information as possible for each <tt class="docutils literal"><span class="pre">OptparseOption</span></tt> that corresponds to an existing <tt class="docutils literal"><span class="pre">CommandIn</span></tt>.</p>
<p>In our example, you&#8217;ll notice that there are two <tt class="docutils literal"><span class="pre">OptparseOptions</span></tt> that are already defined. There are a few values that may need to be changed here. In almost all cases, you&#8217;ll need to change the <tt class="docutils literal"><span class="pre">Type</span></tt>, which is set to the <tt class="docutils literal"><span class="pre">CommandIn</span></tt>&#8216;s <tt class="docutils literal"><span class="pre">DataType</span></tt> value by default, but should be updated to the <tt class="docutils literal"><span class="pre">optparse</span></tt> type. You can find discussion of these types in the <a class="reference internal" href="#optparse-types"><em>optparse type definitions</em></a> section. Note that the <tt class="docutils literal"><span class="pre">Type</span></tt> should be <tt class="docutils literal"><span class="pre">None</span></tt> for command line flags, as the type describes the value that is passed via that option, and command line flags don&#8217;t take a value. The other value that often will need to be changed is <tt class="docutils literal"><span class="pre">Handler</span></tt>, which tells <tt class="docutils literal"><span class="pre">OptparseInterface</span></tt> how to transform the <tt class="docutils literal"><span class="pre">OptparseOption</span></tt> into the corresponding <tt class="docutils literal"><span class="pre">CommandIn</span></tt>. In our case, for our <tt class="docutils literal"><span class="pre">seqs</span></tt> <tt class="docutils literal"><span class="pre">OptparseOption</span></tt>, that involves converting a filepath into a list of tuples of (sequence id, sequence) pairs. First let&#8217;s define the <tt class="docutils literal"><span class="pre">OptparseOptions</span></tt>, and then we&#8217;ll define a new <tt class="docutils literal"><span class="pre">Handler</span></tt>.</p>
<p>The <tt class="docutils literal"><span class="pre">OptparseOptions</span></tt> corresponding to the existing <tt class="docutils literal"><span class="pre">CommandIns</span></tt> should look like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span>

    <span class="n">OptparseOption</span><span class="p">(</span><span class="n">Parameter</span><span class="o">=</span><span class="n">cmd_in_lookup</span><span class="p">(</span><span class="s">&#39;seqs&#39;</span><span class="p">),</span>
                   <span class="n">Type</span><span class="o">=</span><span class="s">&#39;existing_filepath&#39;</span><span class="p">,</span>
                   <span class="n">Action</span><span class="o">=</span><span class="s">&#39;store&#39;</span><span class="p">,</span>
                   <span class="n">Handler</span><span class="o">=</span><span class="n">parse_fasta</span><span class="p">,</span>
                   <span class="n">ShortName</span><span class="o">=</span><span class="s">&#39;i&#39;</span><span class="p">),</span>

    <span class="n">OptparseOption</span><span class="p">(</span><span class="n">Parameter</span><span class="o">=</span><span class="n">cmd_in_lookup</span><span class="p">(</span><span class="s">&#39;suppress_length_summary&#39;</span><span class="p">),</span>
                   <span class="n">Type</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                   <span class="n">Action</span><span class="o">=</span><span class="s">&#39;store_true&#39;</span><span class="p">,</span>
                   <span class="n">Handler</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                   <span class="n">ShortName</span><span class="o">=</span><span class="bp">None</span><span class="p">),</span>
<span class="p">]</span>
</pre></div>
</div>
<p>These definitions are exactly as generated by <tt class="docutils literal"><span class="pre">make-optparse</span></tt>, except that many of the comments have been removed, and we&#8217;ve modified the <tt class="docutils literal"><span class="pre">Types</span></tt> and the <tt class="docutils literal"><span class="pre">Handler</span></tt> for our <tt class="docutils literal"><span class="pre">seqs</span></tt> option. In the <a class="reference internal" href="#defining-input-handlers"><em>next section</em></a> we&#8217;ll define this new <tt class="docutils literal"><span class="pre">parse_fasta</span></tt> input handler, but first we&#8217;ll add one more <tt class="docutils literal"><span class="pre">OptparseOption</span></tt> which is specific to our command line interface.</p>
<p>The output from our <tt class="docutils literal"><span class="pre">SequenceCollectionSummarizer</span></tt> is a dictionary, where some of the values are integers and some of the values may be <tt class="docutils literal"><span class="pre">None</span></tt>. Generally a command line user will want to have information printed to stdout or to file. We&#8217;ll define our interface so that the output is written to file with some basic formatting put in place. To do this, we need to define a new <tt class="docutils literal"><span class="pre">OptparseOption</span></tt> to allow the user to specify the path where output should be written. This <tt class="docutils literal"><span class="pre">OptparseOption</span></tt> does not map onto one of our existing <tt class="docutils literal"><span class="pre">CommandIns</span></tt>, and should be defined as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">OptparseOption</span><span class="p">(</span><span class="n">Parameter</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
               <span class="n">Type</span><span class="o">=</span><span class="s">&#39;new_filepath&#39;</span><span class="p">,</span>
               <span class="n">Action</span><span class="o">=</span><span class="s">&#39;store&#39;</span><span class="p">,</span>
               <span class="n">ShortName</span><span class="o">=</span><span class="s">&#39;o&#39;</span><span class="p">,</span>
               <span class="n">Name</span><span class="o">=</span><span class="s">&#39;output-fp&#39;</span><span class="p">,</span>
               <span class="n">Required</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
               <span class="n">Help</span><span class="o">=</span><span class="s">&#39;path where output should be written&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Notice the <tt class="docutils literal"><span class="pre">Parameter=None</span></tt> parameter here: this indicates that this <tt class="docutils literal"><span class="pre">OptparseOption</span></tt> does not correspond to one of the <tt class="docutils literal"><span class="pre">SequenceCollectionSummarizer</span></tt> <tt class="docutils literal"><span class="pre">CommandIns</span></tt>.</p>
<p>You should include this <tt class="docutils literal"><span class="pre">OptparseOption</span></tt> definition in the <tt class="docutils literal"><span class="pre">inputs</span></tt> list to define the three options for our command line interface.</p>
</div>
<div class="section" id="defining-input-handlers">
<span id="id2"></span><h2>Defining input handlers<a class="headerlink" href="#defining-input-handlers" title="Permalink to this headline">¶</a></h2>
<p>Input handlers tell the <tt class="docutils literal"><span class="pre">OptparseInterface</span></tt> class how to take input from the command line and get it into the form that the <tt class="docutils literal"><span class="pre">Command</span></tt> is expecting. In our case, the user will be providing a filepath on the command line, and our <tt class="docutils literal"><span class="pre">SequenceCollectionSummarizer</span></tt> expects to receive a list (or other iterable object) of tuples of (sequence id, sequence) pairs. Our input handler is therefore a simple fasta parser, which is a <a class="reference external" href="http://docs.python.org/2/tutorial/classes.html#generators">generator</a> of (sequence id, sequence) tuples. We can define this as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">parse_fasta</span><span class="p">(</span><span class="n">fp</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">       fp: path to a fasta-formatted file</span>

<span class="sd">       This function is a fasta record generator, yielding</span>
<span class="sd">        (sequence id, sequence) pairs when provided with a</span>
<span class="sd">        valid fasta file.</span>

<span class="sd">       NO ERROR CHECKING IS PERFORMED!</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Always open files for reading in python using mode &#39;U&#39;</span>
    <span class="c"># to correctly handle different types of line breaks</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span><span class="s">&#39;U&#39;</span><span class="p">)</span>
    <span class="n">seq_id</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">seq</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;&gt;&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c"># we&#39;ve completed a fasta record</span>
                <span class="k">yield</span> <span class="n">seq_id</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
            <span class="n">seq_id</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">seq</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
    <span class="k">yield</span> <span class="n">seq_id</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>This definition can go in the interface configuration file that we&#8217;ve been working on in this tutorial. Alternatively, if your input handler is generally useful for your project you can centralize it within your project (see <a class="reference internal" href="organizing_your_repository.html#organizing-your-repository"><em>Organizing your repository</em></a>), or if you think it&#8217;s generally useful for pyqi users, you should consider submitting it to the pyqi project <a class="reference internal" href="../index.html#contributing-to-pyqi"><em>contributing it to pyqi</em></a>.</p>
</div>
<div class="section" id="defining-outputs">
<h2>Defining outputs<a class="headerlink" href="#defining-outputs" title="Permalink to this headline">¶</a></h2>
<p>The last thing we need to do is define which of the outputs generated by <tt class="docutils literal"><span class="pre">SequenceCollectionSummarizer</span></tt> are things we care about with this interface, and tell our <tt class="docutils literal"><span class="pre">OptparseInterface</span></tt> how to handle those. We do this by defining the <tt class="docutils literal"><span class="pre">outputs</span></tt> list of <tt class="docutils literal"><span class="pre">pyqi.core.interfaces.optparse.OptparseResult</span></tt> objects. In our case, we&#8217;ll want to write all of the values that are not <tt class="docutils literal"><span class="pre">None</span></tt> to the filepath specified by the user with <tt class="docutils literal"><span class="pre">output-fp</span></tt>. To do that, we need to handle three possible outputs, so we&#8217;ll define those outputs and write an output handler. You should start with the stubbed <tt class="docutils literal"><span class="pre">outputs</span></tt> list to define how you want to handle each of the parameters. We&#8217;ll do this as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">outputs</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">OptparseResult</span><span class="p">(</span><span class="n">Parameter</span><span class="o">=</span><span class="n">cmd_out_lookup</span><span class="p">(</span><span class="s">&#39;num_seqs&#39;</span><span class="p">),</span>
                   <span class="n">Handler</span><span class="o">=</span><span class="n">append_datum_to_file</span><span class="p">,</span>
                   <span class="n">InputName</span><span class="o">=</span><span class="s">&#39;output-fp&#39;</span><span class="p">),</span>
    <span class="n">OptparseResult</span><span class="p">(</span><span class="n">Parameter</span><span class="o">=</span><span class="n">cmd_out_lookup</span><span class="p">(</span><span class="s">&#39;min_length&#39;</span><span class="p">),</span>
                   <span class="n">Handler</span><span class="o">=</span><span class="n">append_datum_to_file</span><span class="p">,</span>
                   <span class="n">InputName</span><span class="o">=</span><span class="s">&#39;output-fp&#39;</span><span class="p">),</span>
    <span class="n">OptparseResult</span><span class="p">(</span><span class="n">Parameter</span><span class="o">=</span><span class="n">cmd_out_lookup</span><span class="p">(</span><span class="s">&#39;max_length&#39;</span><span class="p">),</span>
                   <span class="n">Handler</span><span class="o">=</span><span class="n">append_datum_to_file</span><span class="p">,</span>
                   <span class="n">InputName</span><span class="o">=</span><span class="s">&#39;output-fp&#39;</span><span class="p">),</span>

<span class="p">]</span>
</pre></div>
</div>
<p>In this case, each of our <tt class="docutils literal"><span class="pre">OptparseResults</span></tt> are associated with a single <tt class="docutils literal"><span class="pre">InputName</span></tt>: <tt class="docutils literal"><span class="pre">output-fp</span></tt>. We do this because each of these should be written to the same file, but in practice each of these could be associated with different <tt class="docutils literal"><span class="pre">InputNames</span></tt> (e.g., if each should be written to a different file), or <tt class="docutils literal"><span class="pre">InputName=None</span></tt>, if (for example) a particular result should be written to stdout or stderr. We&#8217;ll next define the new output handler, <tt class="docutils literal"><span class="pre">append_datum_to_file</span></tt>, used by each of these <tt class="docutils literal"><span class="pre">OptparseResult</span></tt> objects.</p>
</div>
<div class="section" id="defining-output-handlers">
<h2>Defining output handlers<a class="headerlink" href="#defining-output-handlers" title="Permalink to this headline">¶</a></h2>
<p>Each of these <tt class="docutils literal"><span class="pre">OptparseResult</span></tt> objects use the same <tt class="docutils literal"><span class="pre">Handler</span></tt>, which we need to define now. This will take the result and write it to the file specified by the user as <tt class="docutils literal"><span class="pre">output-fp</span></tt>. This should look like the following:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">append_datum_to_file</span><span class="p">(</span><span class="n">result_key</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">option_value</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Append summary information to a file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># don&#39;t do anything if data is None</span>
    <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="c"># If option_value is None when this output handler is called,</span>
    <span class="c"># the interface developer did something wrong when defining</span>
    <span class="c"># the OptparseResults. Politely alert the developer that</span>
    <span class="c"># this output handler isn&#39;t associated with an option</span>
    <span class="c"># (it needs to be associated with an output filepath).</span>
    <span class="k">if</span> <span class="n">option_value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">IncompetentDeveloperError</span><span class="p">(</span>
         <span class="s">&quot;Cannot write output without a filepath.&quot;</span><span class="p">)</span>

    <span class="c"># open the output file for appending, and write the</span>
    <span class="c"># summary information to a single tab-separated line</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">option_value</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="se">\t</span><span class="si">%d</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">result_key</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="complete-optparseinterface-configuration-file">
<h2>Complete OptparseInterface configuration file<a class="headerlink" href="#complete-optparseinterface-configuration-file" title="Permalink to this headline">¶</a></h2>
<p>At this stage we&#8217;ve fully configured our interface. The final interface configuration file should look like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#!/usr/bin/env python</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>

<span class="n">__credits__</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;Greg Caporaso&quot;</span><span class="p">]</span>

<span class="kn">from</span> <span class="nn">pyqi.core.interfaces.optparse</span> <span class="kn">import</span> <span class="p">(</span><span class="n">OptparseUsageExample</span><span class="p">,</span>
                                           <span class="n">OptparseOption</span><span class="p">,</span> <span class="n">OptparseResult</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">pyqi.core.command</span> <span class="kn">import</span> <span class="p">(</span><span class="n">make_command_in_collection_lookup_f</span><span class="p">,</span>
                               <span class="n">make_command_out_collection_lookup_f</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">sequence_collection_summarizer</span> <span class="kn">import</span> <span class="n">CommandConstructor</span>

<span class="n">cmd_in_lookup</span> <span class="o">=</span> <span class="n">make_command_in_collection_lookup_f</span><span class="p">(</span><span class="n">CommandConstructor</span><span class="p">)</span>
<span class="n">cmd_out_lookup</span> <span class="o">=</span> <span class="n">make_command_out_collection_lookup_f</span><span class="p">(</span><span class="n">CommandConstructor</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">parse_fasta</span><span class="p">(</span><span class="n">fp</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">       fp: path to a fasta-formatted file</span>

<span class="sd">       This function is a fasta record generator, yielding</span>
<span class="sd">        (sequence id, sequence) pairs when provided with a</span>
<span class="sd">        valid fasta file.</span>

<span class="sd">       NO ERROR CHECKING IS PERFORMED!</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Always open files for reading in python using mode &#39;U&#39;</span>
    <span class="c"># to correctly handle different types of line breaks</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span><span class="s">&#39;U&#39;</span><span class="p">)</span>
    <span class="n">seq_id</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">seq</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;&gt;&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c"># we&#39;ve completed a fasta record</span>
                <span class="k">yield</span> <span class="n">seq_id</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
            <span class="n">seq_id</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">seq</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
    <span class="k">yield</span> <span class="n">seq_id</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">append_datum_to_file</span><span class="p">(</span><span class="n">result_key</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">option_value</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Append summary information to a file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># don&#39;t do anything if data is None</span>
    <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="c"># If option_value is None when this output handler is called,</span>
    <span class="c"># the interface developer did something wrong when defining</span>
    <span class="c"># the OptparseResults. Politely alert the developer that</span>
    <span class="c"># this output handler isn&#39;t associated with an option</span>
    <span class="c"># (it needs to be associated with an output filepath).</span>
    <span class="k">if</span> <span class="n">option_value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">IncompetentDeveloperError</span><span class="p">(</span>
         <span class="s">&quot;Cannot write output without a filepath.&quot;</span><span class="p">)</span>

    <span class="c"># open the output file for appending, and write the</span>
    <span class="c"># summary information to a single tab-separated line</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">option_value</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="se">\t</span><span class="si">%d</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">result_key</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span>

<span class="n">usage_examples</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">OptparseUsageExample</span><span class="p">(</span><span class="n">ShortDesc</span><span class="o">=</span><span class="s">&quot;Summarize the input sequence collection and write the result to file.&quot;</span><span class="p">,</span>
                         <span class="n">LongDesc</span><span class="o">=</span><span class="s">&quot;Read the file specified by -i, and compute the number of sequences in the file, and the minimum and maximum sequence lengths. Write all of that information to path specified by -o.&quot;</span><span class="p">,</span>
                         <span class="n">Ex</span><span class="o">=</span><span class="s">&quot;%prog -i seqs.fna -o seqs.summary.txt&quot;</span><span class="p">),</span>
    <span class="n">OptparseUsageExample</span><span class="p">(</span><span class="n">ShortDesc</span><span class="o">=</span><span class="s">&quot;Summarize the input sequence collection and write the result to file, excluding information on sequence lengths.&quot;</span><span class="p">,</span>
                         <span class="n">LongDesc</span><span class="o">=</span><span class="s">&quot;Read the file specified by -i, compute the number of sequences in the file, and write that information to path specified by -o.&quot;</span><span class="p">,</span>
                         <span class="n">Ex</span><span class="o">=</span><span class="s">&quot;%prog -i seqs.fna -o seqs.summary.txt --suppress-length-summary&quot;</span><span class="p">)</span>
<span class="p">]</span>

<span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">OptparseOption</span><span class="p">(</span><span class="n">Parameter</span><span class="o">=</span><span class="n">cmd_in_lookup</span><span class="p">(</span><span class="s">&#39;seqs&#39;</span><span class="p">),</span>
                   <span class="n">Type</span><span class="o">=</span><span class="s">&#39;existing_filepath&#39;</span><span class="p">,</span>
                   <span class="n">Action</span><span class="o">=</span><span class="s">&#39;store&#39;</span><span class="p">,</span>
                   <span class="n">Handler</span><span class="o">=</span><span class="n">parse_fasta</span><span class="p">,</span>
                   <span class="n">ShortName</span><span class="o">=</span><span class="s">&#39;i&#39;</span><span class="p">),</span>
    <span class="n">OptparseOption</span><span class="p">(</span><span class="n">Parameter</span><span class="o">=</span><span class="n">cmd_in_lookup</span><span class="p">(</span><span class="s">&#39;suppress_length_summary&#39;</span><span class="p">),</span>
                   <span class="n">Type</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                   <span class="n">Action</span><span class="o">=</span><span class="s">&#39;store_true&#39;</span><span class="p">,</span>
                   <span class="n">Handler</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                   <span class="n">ShortName</span><span class="o">=</span><span class="bp">None</span><span class="p">),</span>
    <span class="n">OptparseOption</span><span class="p">(</span><span class="n">Parameter</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                   <span class="n">Type</span><span class="o">=</span><span class="s">&#39;new_filepath&#39;</span><span class="p">,</span>
                   <span class="n">Action</span><span class="o">=</span><span class="s">&#39;store&#39;</span><span class="p">,</span>
                   <span class="n">ShortName</span><span class="o">=</span><span class="s">&#39;o&#39;</span><span class="p">,</span>
                   <span class="n">Name</span><span class="o">=</span><span class="s">&#39;output-fp&#39;</span><span class="p">,</span>
                   <span class="n">Required</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                   <span class="n">Help</span><span class="o">=</span><span class="s">&#39;path where output should be written&#39;</span><span class="p">)</span>
<span class="p">]</span>

<span class="n">outputs</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">OptparseResult</span><span class="p">(</span><span class="n">Parameter</span><span class="o">=</span><span class="n">cmd_out_lookup</span><span class="p">(</span><span class="s">&#39;num_seqs&#39;</span><span class="p">),</span>
                   <span class="n">Handler</span><span class="o">=</span><span class="n">append_datum_to_file</span><span class="p">,</span>
                   <span class="n">InputName</span><span class="o">=</span><span class="s">&#39;output-fp&#39;</span><span class="p">),</span>
    <span class="n">OptparseResult</span><span class="p">(</span><span class="n">Parameter</span><span class="o">=</span><span class="n">cmd_out_lookup</span><span class="p">(</span><span class="s">&#39;min_length&#39;</span><span class="p">),</span>
                   <span class="n">Handler</span><span class="o">=</span><span class="n">append_datum_to_file</span><span class="p">,</span>
                   <span class="n">InputName</span><span class="o">=</span><span class="s">&#39;output-fp&#39;</span><span class="p">),</span>
    <span class="n">OptparseResult</span><span class="p">(</span><span class="n">Parameter</span><span class="o">=</span><span class="n">cmd_out_lookup</span><span class="p">(</span><span class="s">&#39;max_length&#39;</span><span class="p">),</span>
                   <span class="n">Handler</span><span class="o">=</span><span class="n">append_datum_to_file</span><span class="p">,</span>
                   <span class="n">InputName</span><span class="o">=</span><span class="s">&#39;output-fp&#39;</span><span class="p">)</span>
<span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="running-our-command-via-its-optparseinterface">
<span id="running-our-command"></span><h2>Running our Command via its OptparseInterface<a class="headerlink" href="#running-our-command-via-its-optparseinterface" title="Permalink to this headline">¶</a></h2>
<p>To run this, there are a couple of additional things you need to do. First, you need to confirm that the directory where you&#8217;ve written these files is accessible via your <tt class="docutils literal"><span class="pre">PYTHONPATH</span></tt>. For example, if you&#8217;ve been working in <tt class="docutils literal"><span class="pre">$HOME/code/pyqi_experiments/</span></tt>, you should have <tt class="docutils literal"><span class="pre">$HOME/code/</span></tt> in your <tt class="docutils literal"><span class="pre">PYTHONPATH</span></tt>. You can add that as follows:</p>
<div class="highlight-python"><pre>export PYTHONPATH=$HOME/code/:$PYTHONPATH</pre>
</div>
<p>Next, so you can import from that directory, it&#8217;ll need to contain an <tt class="docutils literal"><span class="pre">__init__.py</span></tt> file. You can do this as follows:</p>
<div class="highlight-python"><pre>echo '__version__ = "0.0.0"' &gt; $HOME/code/pyqi_experiments/__init__.py</pre>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">pyqi requires that the top-level module containing the configuration files has a <tt class="docutils literal"><span class="pre">__version__</span></tt> attribute defined. <tt class="docutils literal"><span class="pre">__version__</span></tt> should store a version string, e.g., <tt class="docutils literal"><span class="pre">&quot;0.0.0&quot;</span></tt>. In this example, the top-level module is <tt class="docutils literal"><span class="pre">pyqi_experiments</span></tt>, so we must create an <tt class="docutils literal"><span class="pre">__init__.py</span></tt> that contains a <tt class="docutils literal"><span class="pre">__version__</span></tt> attribute.</p>
</div>
<p>Now we&#8217;re ready to run our <tt class="docutils literal"><span class="pre">Command</span></tt> via its <tt class="docutils literal"><span class="pre">OptparseInterface</span></tt>. You can do this as follows:</p>
<div class="highlight-python"><pre>pyqi --command-config-module pyqi_experiments -- summarize-sequence-collection -h</pre>
</div>
<p>This will print the help text associated with the <tt class="docutils literal"><span class="pre">summarize_sequence_collection</span></tt> <tt class="docutils literal"><span class="pre">OptparseInterface</span></tt> configuration file that we just created.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <tt class="docutils literal"><span class="pre">pyqi</span></tt> driver that we used above recognizes command names that match an <tt class="docutils literal"><span class="pre">OptparseInterface</span></tt> configuration file in the <tt class="docutils literal"><span class="pre">--command-config-module</span></tt> directory, minus the <tt class="docutils literal"><span class="pre">.py</span></tt>. For example, we created a <tt class="docutils literal"><span class="pre">summarize_sequence_collection.py</span></tt> configuration file in the <tt class="docutils literal"><span class="pre">pyqi_experiments</span></tt> directory, so the <tt class="docutils literal"><span class="pre">pyqi</span></tt> driver recognizes the <tt class="docutils literal"><span class="pre">summarize_sequence_collection</span></tt> command. It also recognizes the dashed version of a command name, such as <tt class="docutils literal"><span class="pre">summarize-sequence-collection</span></tt>. These names both map to the same command.</p>
</div>
<p>You can test the command by applying it to some sequence collection as follows:</p>
<div class="highlight-python"><pre>pyqi --command-config-module pyqi_experiments -- summarize-sequence-collection -i seqs.fna -o seqs.summary.txt</pre>
</div>
<p>If <tt class="docutils literal"><span class="pre">seqs.fna</span></tt> contains the following:</p>
<div class="highlight-python"><pre>&gt;s1
ACCTTTAACC
&gt;s2
CCGG
&gt;s3
AAAAAAAAAAAAAAAAAAAAAAAAAAA</pre>
</div>
<p>The resulting <tt class="docutils literal"><span class="pre">seqs.summary.txt</span></tt> should contain the following lines:</p>
<div class="highlight-python"><pre>num-seqs        3
min-length      4
max-length      27</pre>
</div>
<p>Calling your command via the pyqi driver itself, as we&#8217;re doing here, is a little clunky. Creating a project-specific driver however is very simple (it&#8217;s a two-line shell script) and is covered in <a class="reference internal" href="defining_your_command_driver.html#defining-your-command-driver"><em>Defining your command driver</em></a>.</p>
</div>
<div class="section" id="optparseoption-types">
<span id="optparse-types"></span><h2>OptparseOption Types<a class="headerlink" href="#optparseoption-types" title="Permalink to this headline">¶</a></h2>
<p>pyqi defines several new option types in addition to the optparse&#8217;s built-in option types. All of the available option types are:</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">option type</th>
<th class="head">brief description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>string</td>
<td>a string</td>
</tr>
<tr class="row-odd"><td>int</td>
<td>an int</td>
</tr>
<tr class="row-even"><td>long</td>
<td>a long</td>
</tr>
<tr class="row-odd"><td>float</td>
<td>a float</td>
</tr>
<tr class="row-even"><td>complex</td>
<td>a complex number</td>
</tr>
<tr class="row-odd"><td>choice</td>
<td>one value from a list of choices</td>
</tr>
<tr class="row-even"><td>existing_path</td>
<td>path to an existing file or directory</td>
</tr>
<tr class="row-odd"><td>new_path</td>
<td>path to a new file or directory</td>
</tr>
<tr class="row-even"><td>existing_filepath</td>
<td>path to an existing file</td>
</tr>
<tr class="row-odd"><td>existing_filepaths</td>
<td>path to one or more existing files</td>
</tr>
<tr class="row-even"><td>new_filepath</td>
<td>path to a new file</td>
</tr>
<tr class="row-odd"><td>existing_dirpath</td>
<td>path to an existing directory</td>
</tr>
<tr class="row-even"><td>existing_dirpaths</td>
<td>path to one or more existing directories</td>
</tr>
<tr class="row-odd"><td>new_dirpath</td>
<td>path to a new directory</td>
</tr>
<tr class="row-even"><td>multiple_choice</td>
<td>one or more values from a list of choices</td>
</tr>
<tr class="row-odd"><td>blast_db</td>
<td>a blast database</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="thoughts-and-guidelines-on-designing-command-line-interfaces">
<h2>Thoughts and guidelines on designing command line interfaces<a class="headerlink" href="#thoughts-and-guidelines-on-designing-command-line-interfaces" title="Permalink to this headline">¶</a></h2>
<p>Based on our experiences developing command line interfaces for <a class="reference external" href="http://www.qiime.org">QIIME</a>, we&#8217;ve compiled some thoughts on best practices, which you can find in <a class="reference internal" href="../guidelines/optparse.html#optparse-guidelines"><em>Guidelines for creating pyqi-based optparse interfaces</em></a>.</p>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        <a class="uplink" href="../index.html">Contents</a>
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2013, The BiPy Development Team.
      Last updated on Dec 04, 2013.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2b1.
    </div>
  </body>
</html>